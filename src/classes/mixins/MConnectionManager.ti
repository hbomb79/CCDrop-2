--[[
    WIP
]]

abstract class MConnectionManager {
    static = {
        ERRORS = {
            CONN_ACCEPT = {
                timeout = "CCDrop accepted the request, but got no response from the target client",
                unknown = "An unknown error prevented CCDrop from accepting the connection request from the target"
            },
            CONN_PROMPT = {
                reject = "The target client denied the transfer request",
                illegal = "This client has been blocked by the target client",
                unknown = "An unknown error meant that the connection could not be established"
            }
        }
    };

    activeConnection = false;
}

--[[
    @instance
    @desc WIP
]]
function MConnectionManager:connectToClient( clientID )
    if self.activeConnection then return end

    local connection = Connection( self, clientID, self.sending )
    connection:connect():fail( function( _, reason )
        self:addNotification( Notification( "Failed to establish connection", MConnectionManager.ERRORS.CONN_PROMPT[ reason ] or MConnectionManager.ERRORS.CONN_PROMPT.unknown, { { "ok", "Okay" } } ) )
        connection:destroy()
        self.state = "discovering"
    end )

    self.state = "transferring"
end

--[[
    @instance
    @desc WIP
]]
function MConnectionManager:updateStatus( title, body, isTerm )
    local pg = self:query "Page#transferring".result[ 1 ]
    pg:query "Label.header":set( "text", title or "Waiting for Connection" )
    pg:query "TextContainer#body":set( "text", body or "CCDrop is waiting for the other client to accept the file transfer request" )
    pg:query "Button#connectionAbort":set { text = isTerm and "Terminate" or "Abort", backgroundColour = isTerm and colours.red or 256, colour = isTerm and 1 or 128 }

    pg:query "ProgressBar":set( "visible", isTerm )
end

--[[
    @instance
    @desc WIP
]]
function MConnectionManager:acceptClientConnection( clientID, paths )
    -- Check that the client is still alive
    local connection = Connection( self, clientID )
    connection.filesToTransfer = #paths
    connection:connect():fail( function( _, reason )
        if not reason or reason ~= "expired" then self:addNotification( Notification( "Failed to establish connection", MConnectionManager.ERRORS.CONN_ACCEPT[ reason ] or MConnectionManager.ERRORS.CONN_ACCEPT.unknown, { { "ok", "Okay" } } ) ) end
        connection:destroy()
    end )
end

--[[
    @instance
    @desc WIP
]]
function MConnectionManager:rejectClientConnection( clientID )
    self:send( MRednet.channels.REPLY, MRednet.channels.REPLY, "REJECT", { target = clientID } )
end
