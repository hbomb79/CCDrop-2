--[[
	WIP
]]

class Connection {
    static = {
        states = {
            IDLE = 0;
            CHECKING = 1;
            PROMPTING = 2;
            CONFIRMATION = 3;
            RECEIVING = 4;
            CLOSING = 5;
            TERMINATING = 6;
        }
    };

    open = false;
    mode = false;
    sending = false;
    state = false;

    def = false;

    cachedPath = 1;
    filesTransferred = 0;
    receivedFiles = {};
    filesToTransfer = 0;
}

--[[
	@instance
	@desc WIP
]]
function Connection:__init__( ccdrop, id, paths )
    self.owner, self.target, self.paths, self.state = ccdrop, id, paths, "idle"
    if paths then self.filesToTransfer = #paths end

    if ccdrop.activeConnection and ccdrop.activeConnection ~= self then
        if ccdrop.activeConnection.open then
            error( "Cannot spawn Connection instance targetting '"..tostring( id ).."'. An active connection is already open on the CCDrop instance." )
        else
            ccdrop.activeConnection:destroy( true )
        end
    else
        ccdrop.activeConnection = self
    end
end

--[[
    @instance
    @desc Ensures the target is still active and is willing and able to accept the files proposed by the transfer
]]
function Connection:connect()
    if self.paths then
        self.state = "prompting"
        self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FILE_PROMPT", { file_list = self.paths, target = self.target } )
    else
        self:resetTimeout( 2 )
        self.state = "checking"
        self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "ACCEPT", { target = self.target } )
    end

    self.owner:updateStatus()
    return self:setDef( Deferred() )
end

--[[
    @instance
    @desc WIP
]]
function Connection:pushFile()
    local path = self.paths[ self.cachedPath ]
    if path then
        -- Send the file
        if not fs.exists( path ) then
            local reason = "Cannot send file '"..path.."', not found"
            self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FAILED", { target = self.target, reason = reason } )
            self:failTransfer( reason )
            return
        end

        local h = fs.open( path, "r" )
        local content = h.readAll()
        h.close()

        self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FILE", { target = self.target, file = content, path = path })
        self:resetTimeout( 5 )
        self.state = "confirmation"
    else
        -- Tell the target we are done
        self.state = "closing"
        self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FINISHED", { target = self.target } )
        self.owner:updateStatus( "Finishing Transfer", "CCDrop is waiting on the other client to finalize the transfer. This should only take a moment or two.", true )

        self:resetTimeout( 5 )
    end
end

function Connection:failTransfer( reason, returnState )
    self.owner.state = returnState or "root"
    -- self.owner:addNotification( Notification( "File Transfer Failed", "The target client failed to send files for reason: " .. ( reason or "unknown reason" ) ))
    self.owner.trouble = "failed"
    self:destroy()

    if self.timeout then os.cancelTimer( self.timeout ) end
end

--[[
    @instance
    @desc WIP
]]
function Connection:resetTimeout( time )
    if self.timeout then os.cancelTimer( self.timeout ) end
    self.timeout = os.startTimer( time or 3 )
end

--[[
    @instance
    @desc WIP
]]
function Connection:handleMessage( message, content )
    if self.state == Connection.states.IDLE or content.sender ~= self.target then return
    elseif content.content == "TERMINATE" then
        -- The target has terminated our (not idle) connection. Let them know we saw this request
        self.owner:send( message.replyChannel, MRednet.channels.REPLY, "TERMINATED", { target = self.target } )

        -- Let this client know the connection was terminated
        self.owner.trouble = "terminated"

        -- Discard this connection
        self.state = "idle"
        self:destroy()
    elseif self.state == Connection.states.CHECKING then
        -- This connection is checking that the client is still alive
        if content.content == "COMMENCING_TRANSFER" then
            -- The target computer responded, and is able to continue
            self.def:accept()

            self.state = "receiving"
            self:resetTimeout()

            self.owner.state = "transferring"
            self.owner:updateStatus( "Transferring files", "CCDrop is transferring the target files to the target...", true )
        elseif content.content == "EXPIRED" then
            self.def:reject "expired"
            self.owner.trouble = "expired"
        end
    elseif self.state == Connection.states.PROMPTING then
        -- This connection is waiting for the target to accept transfer request
        if content.content == "ACCEPT" then
            -- The target accepted. Let it know we are commencing (ie: still alive)
            self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "COMMENCING_TRANSFER", { target = self.target } )
            self.def:accept()

            self:pushFile()
            self.owner:updateStatus( "Transferring files", "CCDrop is transferring the target files to the target...", true )
        elseif content.content == "REJECT" then
            -- The target rejected our request
            self.def:reject "reject"
        elseif content.content == "ILLEGAL" then
            -- The target has blocked this client
            self.def:reject "illegal"
        end
    elseif self.state == Connection.states.RECEIVING then
        -- Waiting to receive files
        if content.content == "FILE" then
            local path = content.path
            if self.receivedFiles[ path ] then
                self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FAILED", { target = self.target, path = path, reason = "File already received" } )
                self:failTransfer( "Duplicate files received from target, including '"..path.."'" )
            else
                self.receivedFiles[ path ], self.filesTransferred = content.file, self.filesTransferred + 1
                self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "CONFIRMED", { target = self.target, path = path } )
            end

            self:resetTimeout()
        elseif content.content == "FAILED" then
            -- The file transfer failed. The target client couldn't send the next file.
            self:failTransfer( content.reason )
        elseif content.content == "FINISHED" then
            -- The file transfer is complete. Save the files and return to menu
            self.owner:updateStatus( "Saving files", "The file transfer has completed, CCDrop is now saving the downloaded files", true )
            local tFS = TI_VFS_RAW.fs
            for path, content in pairs( self.receivedFiles ) do
                if tFS.isReadOnly( path ) then
                    self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FAILED", { target = self.target, path = path, reason = "Path is read only (cannot be modified)" } )
                    self:failTransfer()
                    return
                else
                    local h = tFS.open( path, "w" )
                    h.write( content )
                    h.close()
                end
            end

            self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "SUCCESS", { target = self.target } )
            self.owner.state = "finished"
            self:destroy()
        end
    elseif self.state == Connection.states.CONFIRMATION then
        -- Just sent a file. Waiting for confirmation that the file was received.
        if content.path == self.paths[ self.cachedPath ] then
            if content.content == "CONFIRMED" then
                self.cachedPath, self.filesTransferred = self.cachedPath + 1, self.filesTransferred + 1
                self:pushFile()
            elseif content.content == "FAILED" then
                -- Tell the user the transfer failed. The connection has already been terminated by the other target.
                self:failTransfer( content.reason )
            end
        end
    elseif self.state == Connection.states.CLOSING then
        if content.content == "SUCCESS" then
            self.owner.state = "finished"
            self:destroy()
        elseif content.content == "FAILED" then
            self:failTransfer( content.reason )
        end
    elseif self.state == Connection.states.TERMINATING then
        if content.content == "TERMINATED" then
            self.owner.state = "root"
            self.def:accept()
            self.state = "idle"

            self:destroy()
        end
    end
end

--[[
    @instance
    @desc WIP
]]
function Connection:handleTimeout()
    if self.state == Connection.states.CHECKING or self.state == Connection.states.TERMINATING then
        if self.def then self.def:reject "timeout" end
    elseif self.state == Connection.states.RECEIVING or self.state == Connection.states.CONFIRMATION or self.state == Connection.states.CLOSING then
        self:destroy()
        self.owner.trouble = "connLost"
    end
end

--[[
    @instance
    @desc WIP
]]
function Connection:terminate( force )
    if self.state == Connection.states.IDLE or self.state == Connection.states.PROMPTING then
        self:destroy()
        self.owner.state = "discovering"
    else
        if force then
            -- Forcibly terminate the connection
            self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "TERMINATE", { target = self.target } )
            self:destroy()

            return
        end

        local def, owner = self:setDef( Deferred() ), self.owner

        local diag = owner:addDialog( DialogWindow( 1, 1, 37, 8, "Are you sure?", "Terminating the active connection will cause incomplete data transfer." ) )
        diag:set {
            X = "$parent.width / 2 - self.width / 2",
            Y = "$parent.height / 2 - self.height / 2"
        }

        diag:addNode( Button( "Cancel" ) ):on( "trigger", function() owner:removeDialog( diag ) end)
        diag:addNode( Button( "Terminate Anyway" ) ):on( "trigger", function( this )
            -- The user has decided to terminate
            self.state = "terminating"

            -- Send the target a message letting us know we are forcefuly closing the connection.
            self:resetTimeout( 2 )
            self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "TERMINATE", { target = self.target } )

            -- Change the dialog window to display information regarding the termination attempt
            diag:set { title = "Terminating", closeable = false, body = "Attempting to negotiate connection termination with other client. Please wait" }
            diag:clearNodes()

            def:success( function() owner:removeDialog( diag ) end ):fail( function()
                -- The deffered failed, which means the termination request timed out
                diag:set { closeable = true, title = "No response", body = "We attempted to terminate the remote connection, but saw no response. The target client has likely gone offline so the connecion has been discarded." }
                diag:addNode( Button( "Okay" ) ):on( "trigger", function() owner:removeDialog( diag ) end )

                self:destroy()
                owner.state = "root"
            end )
        end)
    end
end

--[[
    @instance
    @desc WIP
]]
function Connection:destroy()
    if self.owner.activeConnection == self then
        self.owner.activeConnection = nil
    end

    self.state = "idle"
end

--[[
    @setter
    @desc WIP
]]
function Connection:setState( name )
    self.state = Connection.states[ name:upper() ] or error( "Unknown state '"..name.."'" )
end

--[[
    @setter
    @desc WIP
]]
function Connection:setFilesTransferred( filesTransferred )
    self.filesTransferred = filesTransferred
    self.owner:query "ProgressBar".result[ 1 ].percentage = math.floor( ( self.filesTransferred / self.filesToTransfer ) * 100 )
end

--[[
    @setter
    @desc
]]
function Connection:setDef( def, fail )
    if self.def then
        self.def[ fail and "reject" or "accept" ]( self.def )
    end

    self.def = def
    return def
end
