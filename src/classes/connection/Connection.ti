--[[
	WIP
]]

class Connection {
    static = {
        states = {
            IDLE = 0;
            CHECKING = 1;
            PROMPTING = 2;
            CONFIRMATION = 3;
            RECEIVING = 4;
            CLOSING = 5;
            TERMINATING = 6;
            TERMINATED = 7
        }
    };

    open = false;
    mode = false;
    sending = false;
    state = false;

    def = false;

    cachedPath = 1;
    filesTransferred = 0;
    filesToTransfer = 0;
}

--[[
	@instance
	@desc WIP
]]
function Connection:__init__( ccdrop, id, paths )
    self.owner, self.target, self.paths, self.state = ccdrop, id, paths, "idle"
    if paths then self.filesToTransfer = #paths end

    if ccdrop.activeConnection and ccdrop.activeConnection ~= self then
        if ccdrop.activeConnection.open then
            error( "Cannot spawn Connection instance targetting '"..tostring( id ).."'. An active connection is already open on the CCDrop instance." )
        else
            ccdrop.activeConnection:destroy( true )
        end
    else
        ccdrop.activeConnection = self
    end
end

--[[
    @instance
    @desc Ensures the target is still active and is willing and able to accept the files proposed by the transfer
]]
function Connection:connect()
    if self.paths then
        self.state = "prompting"
        self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FILE_PROMPT", { file_list = self.paths, target = self.target } )
    else
        self:resetTimeout( 2 )
        self.state = "checking"
        self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "ACCEPT", { target = self.target } )
    end

    return self:setDef( Deferred() )
end

--[[
    @instance
    @desc WIP
]]
function Connection:pushFile()
    local path = self.paths[ self.cachedPath ]
    if path then
        -- Send the file
        if not fs.exists( path ) then
            -- Path not found. Terminate the connection
            -- self:terminate()
            error("Cannot send file. Path '"..path.."' doesn't exist")
        end

        --local h = fs.open( path, "r" )
        --local content = h.readAll()
        --h.close()

        self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FILE", { target = self.target, file = "TEST", path = path })
        self:resetTimeout( 5 )
        self.state = "confirmation"
    else
        -- Tell the target we are done
        self.state = "closing"
        self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "FINISHED", { target = self.target } )
    end
end

--[[
    @instance
    @desc WIP
]]
function Connection:handleMessage( message, content )
    if self.state == Connection.states.IDLE or content.sender ~= self.target then return
    elseif self.state == Connection.states.CHECKING then
        -- This connection is checking that the client is still alive
        if content.content == "COMMENCING_TRANSFER" then
            -- The target computer responded, and is able to continue
            self.def:accept()

            self.state = "receiving"
            self:resetTimeout()

            self.owner.state = "transferring"
            self.owner:updateStatus( "Waiting for files", "You have accepted a file transfer. It will begin shortly", true )
        elseif content.content == "EXPIRED" then
            self.def:reject "expired"
            self.owner.trouble = "expired"
        end
    elseif self.state == Connection.states.PROMPTING then
        -- This connection is waiting for the target to accept transfer request
        if content.content == "ACCEPT" then
            -- The target accepted. Let it know we are commencing (ie: still alive)
            self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "COMMENCING_TRANSFER", { target = self.target } )
            self.def:accept()

            self:pushFile()
            self.owner:updateStatus( "Transferring files", "CCDrop is transferring the target files to the target...", true )
        elseif content.content == "REJECT" then
            -- The target rejected our request
            self.def:reject "reject"
        elseif content.content == "ILLEGAL" then
            -- The target has blocked this client
            self.def:reject "illegal"
        end
    elseif self.state == Connection.states.RECEIVING then
        -- Waiting to receive files
        if content.content == "FILE" then
            -- Grab file contents (content.file)
            --TODO

            -- Respond to sender
            self.owner:send( MRednet.channels.SEND, MRednet.channels.REPLY, "CONFIRMED", { target = self.target, path = content.path } )
            self.filesTransferred = self.filesTransferred + 1

            self:resetTimeout()
        end
    elseif self.state == Connection.states.CONFIRMATION then
        -- Just sent a file. Waiting for confirmation that the file was received.
        if content.content == "CONFIRMED" and content.path == self.paths[ self.cachedPath ] then
            self.cachedPath, self.filesTransferred = self.cachedPath + 1, self.filesTransferred + 1
            self:pushFile()
        end
    end
end

function Connection:resetTimeout( time )
    if self.timeout then os.cancelTimer( self.timeout ) end
    self.timeout = os.startTimer( time or 3 )
end

function Connection:handleTimeout()
    if self.state == Connection.states.CHECKING then
        if self.def then self.def:reject "timeout" end
    elseif self.state == Connection.states.RECEIVING or self.state == Connection.states.CONFIRMATION then
        self:destroy()
        self.owner.trouble = "connLost"
    end
end

function Connection:destroy()
    if self.owner.activeConnection == self then
        self.owner.activeConnection = nil
    end
end

function Connection:terminate()
    if self.state == Connection.states.IDLE or self.state == Connection.states.PROMPTING then
        self:destroy()
        self.owner.state = "discovering"
    else
        --TODO: Negotiate termination
    end
end

--[[
    @setter
    @desc WIP
]]
function Connection:setState( name )
    self.state = Connection.states[ name:upper() ] or error( "Unknown state '"..name.."'" )
end

--[[
    @setter
    @desc WIP
]]
function Connection:setFilesTransferred( filesTransferred )
    self.filesTransferred = filesTransferred
    self.owner:query "ProgressBar".result[ 1 ].percentage = math.floor( ( self.filesTransferred / self.filesToTransfer ) * 100 )
end

--[[
    @setter
    @desc
]]
function Connection:setDef( def, fail )
    if self.def then
        self.def[ fail and "reject" or "resolve" ]( self.def )
    end

    self.def = def
    return def
end
